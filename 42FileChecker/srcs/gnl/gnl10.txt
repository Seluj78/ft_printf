MATH(3)                  BSD Library Functions Manual                  MATH(3)NNAAMMEE     mmaatthh -- mathematical library functionsSSYYNNOOPPSSIISS     ##iinncclluuddee <<mmaatthh..hh>>DDEESSCCRRIIPPTTIIOONN     The header file math.h provides function prototypes and macros for work-     ing with floating point values.     Each math.h function is provided in three variants: single, double and     extended precision.  The single and double precision variants operate on     IEEE-754 single and double precision values, which correspond to the C     types _f_l_o_a_t and _d_o_u_b_l_e, respectively.     On Intel Macs, the C type _l_o_n_g _d_o_u_b_l_e corresponds to 80-bit IEEE-754 dou-     ble extended precision.  On iOS devices using ARM processors, _l_o_n_g _d_o_u_b_l_e     is mapped to _d_o_u_b_l_e, as there is no hardware-supported wider type.     Details of the floating point formats can be found via "man float".     Users who need to repeatedly perform the same calculation on a large set     of data will probably find that the vector math library (composed of     vMathLib and vForce) yields better performance for their needs than     sequential calls to the libm.     Users who need to perform mathematical operations on complex floating-     point numbers should consult the man pages for the complex portion of the     math library, via "man complex".LLIISSTT OOFF FFUUNNCCTTIIOONNSS     Each of the functions that use floating-point values are provided in sin-     gle, double, and extended precision; the double precision prototypes are     listed here.  The man pages for the individual functions provide more     details on their use, special cases, and prototypes for their single and     extended precision versions.     _i_n_t ffppccllaassssiiffyy(_d_o_u_b_l_e)     _i_n_t iissffiinniittee(_d_o_u_b_l_e)     _i_n_t iissiinnff(_d_o_u_b_l_e)     _i_n_t iissnnaann(_d_o_u_b_l_e)     _i_n_t iissnnoorrmmaall(_d_o_u_b_l_e)     _i_n_t ssiiggnnbbiitt(_d_o_u_b_l_e)     These function-like macros are used to classify a single floating-point     argument.     _d_o_u_b_l_e ccooppyyssiiggnn(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e nneexxttaafftteerr(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ccooppyyssiiggnn(_x_, _y) returns the value equal in magnitude to _x with the sign of     _y.  nneexxttaafftteerr(_x_, _y) returns the next floating-point number after _x in the     direction of _y.  Both are correctly-rounded.     _d_o_u_b_l_e nnaann(_c_o_n_s_t _c_h_a_r _*_t_a_g)     The nnaann() function returns a quiet NaN, without raising the invalid flag.     _d_o_u_b_l_e cceeiill(_d_o_u_b_l_e)     _d_o_u_b_l_e fflloooorr(_d_o_u_b_l_e)     _d_o_u_b_l_e nneeaarrbbyyiinntt(_d_o_u_b_l_e)     _d_o_u_b_l_e rriinntt(_d_o_u_b_l_e)     _d_o_u_b_l_e rroouunndd(_d_o_u_b_l_e)     _l_o_n_g _i_n_t llrriinntt(_d_o_u_b_l_e)     _l_o_n_g _i_n_t llrroouunndd(_d_o_u_b_l_e)     _l_o_n_g _l_o_n_g _i_n_t llllrriinntt(_d_o_u_b_l_e)     _l_o_n_g _l_o_n_g _i_n_t llllrroouunndd(_d_o_u_b_l_e)     _d_o_u_b_l_e ttrruunncc(_d_o_u_b_l_e)     These functions provide various means to round floating-point values to     integral values.  They are correctly rounded.     _d_o_u_b_l_e ffmmoodd(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e rreemmaaiinnddeerr(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e rreemmqquuoo(_d_o_u_b_l_e _x_, _d_o_u_b_l_e _y_, _i_n_t _*)     These return a remainder of the division of x by y with an integral quo-     tient.  rreemmqquuoo() additionally provides access to a few lower bits of the     quotient.  They are correctly rounded.     _d_o_u_b_l_e ffddiimm(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e ffmmaaxx(_d_o_u_b_l_e_, _d_o_u_b_l_e)     _d_o_u_b_l_e ffmmiinn(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ffmmaaxx(_x_, _y) and ffmmiinn(_x_, _y) return the maximum and minimum of _x and _y,     respectively.  ffddiimm(_x_, _y) returns the positive difference of _x and _y. _A_l_l     _a_r_e _c_o_r_r_e_c_t_l_y _r_o_u_n_d_e_d_.     _d_o_u_b_l_e ffmmaa(_d_o_u_b_l_e _x_, _d_o_u_b_l_e _y_, _d_o_u_b_l_e _z)     ffmmaa(_x_, _y_, _z) computes the value (x*y) + z as though without intermediate     rounding.  It is correctly rounded.     _d_o_u_b_l_e ffaabbss(_d_o_u_b_l_e)     _d_o_u_b_l_e ssqqrrtt(_d_o_u_b_l_e)     _d_o_u_b_l_e ccbbrrtt(_d_o_u_b_l_e)     _d_o_u_b_l_e hhyyppoott(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ffaabbss(_x), ssqqrrtt(_x), and ccbbrrtt(_x) return the absolute value, square root, and     cube root of _x, respectively.  hhyyppoott(_x_, _y) returns sqrt(x*x + y*y).     ffaabbss() and ssqqrrtt() are correctly rounded.     _d_o_u_b_l_e eexxpp(_d_o_u_b_l_e)     _d_o_u_b_l_e eexxpp22(_d_o_u_b_l_e)     _d_o_u_b_l_e ____eexxpp1100(_d_o_u_b_l_e)     _d_o_u_b_l_e eexxppmm11(_d_o_u_b_l_e)     eexxpp(_x), eexxpp22(_x), ____eexxpp1100(_x), and eexxppmm11(_x) return e**x, 2**x, 10**x, and     e**x - 1, respectively.     _d_o_u_b_l_e lloogg(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg22(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg1100(_d_o_u_b_l_e)     _d_o_u_b_l_e lloogg11pp(_d_o_u_b_l_e)     lloogg(_x), lloogg22(_x), and lloogg1100(_x) return the natural, base-2, and base-10     logarithms of _x, respectively.  lloogg11pp(_x) returns the natural log of 1+x.     _d_o_u_b_l_e llooggbb(_d_o_u_b_l_e)     _i_n_t iillooggbb(_d_o_u_b_l_e)     llooggbb(_x) and iillooggbb(_x) return the exponent of _x.     _d_o_u_b_l_e mmooddff(_d_o_u_b_l_e_, _d_o_u_b_l_e _*)     _d_o_u_b_l_e ffrreexxpp(_d_o_u_b_l_e_, _i_n_t _*)     mmooddff(_x_, _&_y) returns the fractional part of _x and stores the integral part     in _y.  ffrreexxpp(_x_, _&_n) returns the mantissa of _x and stores the exponent in     _n. _T_h_e_y _a_r_e _c_o_r_r_e_c_t_l_y _r_o_u_n_d_e_d_.     _d_o_u_b_l_e llddeexxpp(_d_o_u_b_l_e_, _i_n_t)     _d_o_u_b_l_e ssccaallbbnn(_d_o_u_b_l_e_, _i_n_t)     _d_o_u_b_l_e ssccaallbbllnn(_d_o_u_b_l_e_, _l_o_n_g _i_n_t)     llddeexxpp(_x_, _n), ssccaallbbnn(_x_, _n), and ssccaallbbllnn(_x_, _n) return x*2**n.  They are     correctly rounded.     _d_o_u_b_l_e ppooww(_d_o_u_b_l_e_, _d_o_u_b_l_e)     ppooww(_x_,_y) returns x raised to the power y.     _d_o_u_b_l_e ccooss(_d_o_u_b_l_e)     _d_o_u_b_l_e ssiinn(_d_o_u_b_l_e)     _d_o_u_b_l_e ttaann(_d_o_u_b_l_e)     ccooss(_x), ssiinn(_x), and ttaann(_x) return the cosine, sine and tangent of _x,     respectively.  Note that _x is interpreted as specifying an angle in radi-     ans.     _d_o_u_b_l_e ccoosshh(_d_o_u_b_l_e)     _d_o_u_b_l_e ssiinnhh(_d_o_u_b_l_e)     _d_o_u_b_l_e ttaannhh(_d_o_u_b_l_e)     ccoosshh(_x), ssiinnhh(_x), and ttaannhh(_x) return the hyperbolic cosine, hyperbolic     sine and hyperbolic tangent of _x, respectively.     _d_o_u_b_l_e aaccooss(_d_o_u_b_l_e)     _d_o_u_b_l_e aassiinn(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaann(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaann22(_d_o_u_b_l_e_, _d_o_u_b_l_e)     aaccooss(_x), aassiinn(_x), and aattaann(_x) return the inverse cosine, inverse sine and     inverse tangent of _x, respectively.  Note that the result is an angle in     radians.  aattaann22(_y_, _x) returns the inverse tangent of y/x in radians, with     sign chosen according to the quadrant of (x,y).     _d_o_u_b_l_e aaccoosshh(_d_o_u_b_l_e)     _d_o_u_b_l_e aassiinnhh(_d_o_u_b_l_e)     _d_o_u_b_l_e aattaannhh(_d_o_u_b_l_e)     aaccoosshh(_x), aassiinnhh(_x), and aattaannhh(_x) return the inverse hyperbolic cosine,     inverse hyperbolic sine and inverse hyperbolic tangent of _x, respec-     tively.     _d_o_u_b_l_e ttggaammmmaa(_d_o_u_b_l_e)     _d_o_u_b_l_e llggaammmmaa(_d_o_u_b_l_e)     ttggaammmmaa(_x) and llggaammmmaa(_x) return the values of the gamma function and its     logarithm evalutated at _x, respectively.     _d_o_u_b_l_e jj00(_d_o_u_b_l_e)     _d_o_u_b_l_e jj11(_d_o_u_b_l_e)     _d_o_u_b_l_e jjnn(_i_n_t, _d_o_u_b_l_e)     _d_o_u_b_l_e yy00(_d_o_u_b_l_e)     _d_o_u_b_l_e yy11(_d_o_u_b_l_e)     _d_o_u_b_l_e yynn(_i_n_t, _d_o_u_b_l_e)     jj00(_x), jj11(_x), and jjnn(_x) return the values of the zeroth, first, and nth     Bessel function of the first kind evaluated at _x, respectively.  yy00(_x),     yy11(_x), and yynn(_x) return the values of the zeroth, first, and nth Bessel     function of the second kind evaluated at _x, respectively.     _d_o_u_b_l_e eerrff(_d_o_u_b_l_e)     _d_o_u_b_l_e eerrffcc(_d_o_u_b_l_e)     eerrff(_x) and eerrffcc(_x) return the values of the error function and the com-     plementary error function evaluated at _x, respectively.MMAATTHHEEMMAATTIICCAALL CCOONNSSTTAANNTTSS     In addition to the functions listed above, math.h defines a number of     useful constants, listed below.     CONSTANT        VALUE     M_E             base of natural logarithm, e     M_LOG2E         log2(e)     M_LOG10E        log10(e)     M_LN2           ln(2)     M_LN10          ln(10)     M_PI            pi     M_PI_2          pi / 2     M_PI_4          pi / 4     M_1_PI          1 / pi     M_2_PI          2 / pi     M_2_SQRTPI      2 / sqrt(pi)     M_SQRT2         sqrt(2)     M_SQRT1_2       sqrt(1/2)IIEEEEEE SSTTAANNDDAARRDD 775544 FFLLOOAATTIINNGG--PPOOIINNTT AARRIITTHHMMEETTIICC     The libm functions declared in math.h provide mathematical library func-     tions in single-, double-, and extended-precision IEEE-754 floating-point     formats on Intel macs, and in single- and double-precision IEEE-754     floating-point formats on PowerPC macs.SSEEEE AALLSSOO     float(3), complex(3)SSTTAANNDDAARRDDSS     The <math.h> functions conform to the ISO/IEC 9899:2011 standard.BSD                             August 16, 2012                            BSD
